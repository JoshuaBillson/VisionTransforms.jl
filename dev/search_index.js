var documenterSearchIndex = {"docs":
[{"location":"#VisionTransforms","page":"Home","title":"VisionTransforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for VisionTransforms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#VisionTransforms.ColorJitter","page":"Home","title":"VisionTransforms.ColorJitter","text":"ColorJitter(;strength=5)\n\nApply a random color jitter consisting of contrast, brightness, and hue adjustments. Use strength to determine the maximum extent of the jittering, with a value in the range [1,10].\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.ComposedTransform","page":"Home","title":"VisionTransforms.ComposedTransform","text":"ComposedTransform(transforms...)\n\nApply transforms to the input in the same order as they are given.\n\nExample\n\njulia> r = Raster(rand(256,256, 3), (X,Y,Band));\n\njulia> t = Resample(2.0) |> Tensor();\n\njulia> apply(t, Image(), r, 123) |> size\n(512, 512, 3, 1)\n\njulia> apply(t, Image(), r, 123) |> typeof\nArray{Float32, 4}\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Crop","page":"Home","title":"VisionTransforms.Crop","text":"Crop(from::CropFrom, sz::Tuple)\n\nCrop a raster of size sz from the location specified by from.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Flip","page":"Home","title":"VisionTransforms.Flip","text":"Flip(dim::Int; p=1.0)\n\nFlip the input raster along the specified dimension with probability p.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Grayscale","page":"Home","title":"VisionTransforms.Grayscale","text":"Grayscale(;p=1.0)\n\nConvert to grayscale by averaging the channel dimension with probability p.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.InvertColor","page":"Home","title":"VisionTransforms.InvertColor","text":"InvertColor(;p=1.0)\n\nApply a random color inversion with probability p.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Normalize","page":"Home","title":"VisionTransforms.Normalize","text":"Normalize(;mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])\n\nNormalize the channels to have a mean of 0 and a standard deviation of 1.\n\nParameters\n\nmean: The channel-wise mean of the input data (uses the ImageNet mean by default).\nstd: The channel-wise standard deviation of the input data (uses the ImageNet std by default).\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.PerImageNormalize","page":"Home","title":"VisionTransforms.PerImageNormalize","text":"PerImageNormalize()\n\nNormalize the channels to have a mean of 0 and a standard deviation of 1 based on statistics calculated for each image in a batch.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.PerImageScale","page":"Home","title":"VisionTransforms.PerImageScale","text":"PerImageScale(;lower=0.02, upper=0.98)\n\nApply a linear stretch to scale all values to the range [0, 1]. The arguments lower and upper specify the percentiles at which to define the lower and upper bounds from each channel in the source image. Values that either fall below lower or above upper will be clamped.\n\nParameters\n\nlower: The quantile to use as the lower-bound in the source array.\nupper: The quantile to use as the upper-bound in the source array.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Resize","page":"Home","title":"VisionTransforms.Resize","text":"Resize(sz::Tuple)\n\nResample x according to the specified scale. Mask types will always be resampled with :near interpolation, whereas Images will be resampled with  either :bilinear (scale > 1) or :average (scale < 1).\n\nParameters\n\nx: The image/mask to be resampled.\nsz: The size of the output image.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Rot90","page":"Home","title":"VisionTransforms.Rot90","text":"Rot90(;p=1.0)\n\nApply a random 90 degree rotation with probability p.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Scale","page":"Home","title":"VisionTransforms.Scale","text":"Scale(lower::Vector{<:Real}, upper::Vector{<:Real})\n\nApply a linear stretch to scale all values to the range [0, 1]. The arguments lower and upper specify the lower and upper bounds from each channel in the source image. Values that  either fall below lower or above upper will be clamped.\n\nParameters\n\nlower: The lower-bounds to use for each channel in the source image.\nupper: The upper-bounds to use for each channel in the source image.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Solarize","page":"Home","title":"VisionTransforms.Solarize","text":"Solarize(;p=1.0, threshold=0.75)\n\nRandomly solarize an image with probability p.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.Zoom","page":"Home","title":"VisionTransforms.Zoom","text":"Zoom(from::CropFrom; strength=1.0:0.1:2.0)\n\nZoom to the location specified by from by a factor sampled from strength.\n\n\n\n\n\n","category":"type"},{"location":"#VisionTransforms.CenterCrop-Tuple{Any}","page":"Home","title":"VisionTransforms.CenterCrop","text":"CenterCrop(sz)\n\nCrops a tile of size sz from the center.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.CenterZoom-Tuple{}","page":"Home","title":"VisionTransforms.CenterZoom","text":"CenterZoom(;strength=1.0:0.1:2.0)\n\nZoom to the center of a mask/image by a factor sampled from strength.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.FlipX-Tuple{}","page":"Home","title":"VisionTransforms.FlipX","text":"FlipX(;p=1.0)\n\nApply a random horizontal flip with probability p.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.FlipY-Tuple{}","page":"Home","title":"VisionTransforms.FlipY","text":"FlipY(;p=1.0)\n\nApply a random vertical flip with probability p.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.FlipZ-Tuple{}","page":"Home","title":"VisionTransforms.FlipZ","text":"FlipZ(;p=1.0)\n\nApply a random depth flip with probability p.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.OriginCrop-Tuple{Any}","page":"Home","title":"VisionTransforms.OriginCrop","text":"OriginCrop(sz)\n\nCrops a tile of size sz from the origin.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.RandomCrop-Tuple{Any}","page":"Home","title":"VisionTransforms.RandomCrop","text":"RandomCrop(sz)\n\nCrops a randomly placed tile of size sz.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.RandomZoom-Tuple{}","page":"Home","title":"VisionTransforms.RandomZoom","text":"RandomZoom(;strength=1.0:0.1:2.0)\n\nZoom to a random point by a factor sampled from strength.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.add_noise-Union{Tuple{N}, Tuple{T}, Tuple{Integer, Distributions.Distribution, AbstractArray{T, N}}} where {T<:Real, N}","page":"Home","title":"VisionTransforms.add_noise","text":"add_noise(seed::Integer, dist::Distributions.Distribution, x::AbstractArray{<:Real,N}; channeldim=N, correlated=true)\n\nAdd noise generated by the distribution dist to the image tensor x.\n\nParameters\n\nseed: A seed to make the outcome reproducible.\ndist: A Distributions.Distribution object from which to sample the noise.\nx: A tensor containing a 2D or 3D image or image series.\ncorrelated: If true, applies the same noise value to each channel in the image.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.adjust_brightness-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}} where T<:Real","page":"Home","title":"VisionTransforms.adjust_brightness","text":"adjust_brightness(x::AbstractArray, brightness::Real)\n\nAdjust the brightness of x by brightness.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.adjust_contrast-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Real}} where {T<:Real, N}","page":"Home","title":"VisionTransforms.adjust_contrast","text":"adjust_contrast(x::AbstractArray, contrast::Real, channeldim::Int)\n\nAdjust the contrast of x by contrast.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.blur-Tuple{AbstractArray{<:Real}, Number}","page":"Home","title":"VisionTransforms.blur","text":"blur(x::AbstractArray{<:Real}, strength::Tuple; ndims::Integer=2)\nblur(x::AbstractArray{<:Real}, strength::Number; ndims::Integer=2)\n\nBlur the image x by applying a gaussian filter with a standard deviation of strength.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.color_jitter-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}, Int64}} where T<:Real","page":"Home","title":"VisionTransforms.color_jitter","text":"color_jitter(rng, x::AbstractArray, strength::Int, [channeldim])\n\nApplies random color jittering transformations (hue, saturation, and brightness) to  the input image x.\n\nParameters\n\nrng: A random number generator to make the outcome reproducible.\nx: A tensor containing an RGB image or image series.\nstrength: The strength of the jittering, from 1 to 10.\nchanneldim: The dimension corresponding to channels in x.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.crop-Union{Tuple{N2}, Tuple{N1}, Tuple{CropFrom, NTuple{N1, Int64}, AbstractArray{<:Any, N2}, Int64}} where {N1, N2}","page":"Home","title":"VisionTransforms.crop","text":"crop(from::CropFrom, sz::NTuple{N1,Int}, x::AbstractArray{<:Any,N2}, seed::Int)\n\nCrop x to sz with the upper-left corner specified by from.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.grayscale-Union{Tuple{AbstractArray{<:Real, N}}, Tuple{N}, Tuple{AbstractArray{<:Real, N}, Any}} where N","page":"Home","title":"VisionTransforms.grayscale","text":"grayscale(x::AbstractArray, [channeldim])\n\nConvert x to a grayscale image.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.imresize-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{<:Real, N1}, NTuple{N2, Int64}, Symbol}} where {N1, N2}","page":"Home","title":"VisionTransforms.imresize","text":"imresize(img::AbstractArray, sz::Tuple, method::Symbol)\n\nResize img to sz with the specified resampling method.\n\nParameters\n\nimg: The image to be resized.\nsz: The width and height of the output as a tuple.\nmethod: Either :nearest or :bilinear.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.invert_color-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Real","page":"Home","title":"VisionTransforms.invert_color","text":"invert_color(x::AbstractArray{<:Real})\n\nInvert the colors of x.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.linear_stretch-Union{Tuple{N}, Tuple{AbstractArray{<:Real, N}, Vector{<:Real}, Vector{<:Real}, Int64}} where N","page":"Home","title":"VisionTransforms.linear_stretch","text":"linear_stretch(x::AbstractArray, lower::Vector{<:Real}, upper::Vector{<:Real}, channel_dim::Int)\n\nPerform a linear histogram stretch on x such that lower is mapped to 0 and upper is mapped to 1. Values outside the interval [lower, upper] will be clamped.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.multiply_noise-Union{Tuple{N}, Tuple{T}, Tuple{Integer, Distributions.Distribution, AbstractArray{T, N}}} where {T<:Real, N}","page":"Home","title":"VisionTransforms.multiply_noise","text":"multiply_noise(seed::Integer, dist::Distributions.Distribution, x::AbstractArray{<:Real,N}; channeldim=N, correlated=true)\n\nMultiply noise generated by the distribution dist to the image tensor x.\n\nParameters\n\nseed: A seed to make the outcome reproducible.\ndist: A Distributions.Distribution object from which to sample the noise.\nx: A tensor containing a 2D or 3D image or image series.\ncorrelated: If true, applies the same noise value to each channel in the image.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.normalize-Tuple{AbstractArray{<:Integer}, Vararg{Any}}","page":"Home","title":"VisionTransforms.normalize","text":"normalize(x::AbstractArray{<:Number,N}, μ::AbstractVector, σ::AbstractVector; channeldim=N)\n\nNormalize the input array with respect to the specified dimension so that the mean is 0 and the standard deviation is 1.\n\nParameters\n\nx: A tensor containing one or more 2D or 3D images or 2D image series.\nμ: A Vector of means for each index in channeldim.\nσ: A Vector of standard deviations for each index in channeldim.\nchanneldim: The dimension corresponding to channels in x.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.per_image_linear_stretch-Union{Tuple{N}, Tuple{AbstractArray{<:Real, N}, Real, Real, Int64}} where N","page":"Home","title":"VisionTransforms.per_image_linear_stretch","text":"per_image_linear_stretch(x::AbstractArray, lower::Real, upper::Real, channel_dim::Int)\n\nApply a linear stretch to scale all values to the range [0, 1]. The arguments lower and upper specify the percentiles at which to define the lower and upper bounds from each channel in the source image. Values that either fall below lower or above upper will be clamped.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.per_image_normalize-Tuple{AbstractArray{<:Integer}}","page":"Home","title":"VisionTransforms.per_image_normalize","text":"per_image_normalize(x::AbstractArray{<:Number,N}; channeldim=N, obsdim=nothing)\n\nNormalize the input array so that the mean and standard deviation of each channel is 0 and 1, respectively. Unlike normalize, this method will compute new statistics for each image in x. This is more computationally expensive, but may be more suitable when there is significant domain shift between train and test images. \n\nParameters\n\nx: A tensor containing one or more 2D or 3D images or 2D image series.\nchanneldim: The dimension corresponding to the image channel.\nobsdim: The dimension corresponding to observations if present.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.permute_channels-Union{Tuple{N}, Tuple{T}, Tuple{Any, AbstractArray{T, N}}, Tuple{Any, AbstractArray{T, N}, Any}} where {T<:Real, N}","page":"Home","title":"VisionTransforms.permute_channels","text":"permute_channels(rng, x::AbstractArray, [channeldim])\n\nPermute the channel ordering of x.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.posterize-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T<:Real","page":"Home","title":"VisionTransforms.posterize","text":"posterize(x::AbstractArray, nbits::Int)\n\nPosterize an image x by reducing the number of bits for each color channel to nbits.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.rot90-Union{Tuple{AbstractArray{<:Any, N}}, Tuple{N}} where N","page":"Home","title":"VisionTransforms.rot90","text":"rot90(x)\n\nRotate the image x by 90 degress. \n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.sharpen-Union{Tuple{N}, Tuple{AbstractArray{<:Real, N}, Real}} where N","page":"Home","title":"VisionTransforms.sharpen","text":"sharpen(x::AbstractArray, strength::Real, channeldim::Int)\n\nSharpen the image x by applying a high-frequency-boosting filter.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.shift_hue-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Real}, Tuple{AbstractArray{T, N}, Real, Any}} where {T<:Real, N}","page":"Home","title":"VisionTransforms.shift_hue","text":"shift_hue(x::AbstractArray, shift::Real, [channeldim])\n\nShift the hue of x in the HSV color space by the amount specified by shift.\n\n\n\n\n\n","category":"method"},{"location":"#VisionTransforms.solarize-Tuple{AbstractArray{<:Real}}","page":"Home","title":"VisionTransforms.solarize","text":"solarize(x::AbstractArray{<:Real}; threshold=0.75)\n\nSolarize x by inverting all values above threshold.\n\n\n\n\n\n","category":"method"}]
}
